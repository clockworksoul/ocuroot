// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.920
package mermaid

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

import (
	"fmt"
	"github.com/ocuroot/ocuroot/sdk"
	"github.com/ocuroot/ocuroot/store/models"
	"strings"
)

// FunctionChainDiagram renders a mermaid diagram for a function chain
// If showOnlyActive is true, it will only show functions that are in progress or pending
func FunctionChainDiagram(chain *models.FunctionChainSummary, showOnlyActive bool) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<style>\n\t\t/* Mermaid diagram container */\n\t\t.mermaid-wrapper {\n\t\t\tpadding: 5px 0;\n\t\t}\n\t\t.mermaid-wrapper svg {\n\t\t\tmax-width: 100%;\n\t\t\theight: auto !important;\n\t\t}\n\t</style><!-- Load and initialize Mermaid --><script src=\"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js\"></script><script>\n\t\tdocument.addEventListener('DOMContentLoaded', async function() {\n\t\t\tmermaid.initialize({ \n\t\t\t\tstartOnLoad: false,\n\t\t\t\ttheme: 'neutral',\n\t\t\t\tflowchart: {\n\t\t\t\t\tuseMaxWidth: true,\n\t\t\t\t\thtmlLabels: true,\n\t\t\t\t\tcurve: 'basis',\n\t\t\t\t\trankSpacing: 15,\n\t\t\t\t\tnodeSpacing: 15\n\t\t\t\t},\n\t\t\t\tsecurityLevel: 'loose'\n\t\t\t});\n\n\t\t\tconst elements = document.querySelectorAll('.mermaid');\n\t\t\tfor (const element of elements) {\n\t\t\t\ttry {\n\t\t\t\t\tconst source = element.getAttribute('data-source');\n\t\t\t\t\tawait mermaid.parse(source);\n\t\t\t\t\tawait mermaid.init(undefined, element);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Mermaid rendering error:', error);\n\t\t\t\t\tconsole.error('Failed diagram source:', element.getAttribute('data-source'));\n\t\t\t\t\telement.className = 'mermaid-error';\n\t\t\t\t\telement.innerHTML = `<pre style=\"color: red; white-space: pre-wrap;\">Error rendering diagram:\n${error.message}</pre>`;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t</script><div class=\"mermaid-wrapper overflow-x-auto overflow-y-hidden w-full\"><div class=\"mermaid w-full\" style=\"max-width: 100%;\" data-source=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var2 string
		templ_7745c5c3_Var2, templ_7745c5c3_Err = templ.JoinStringErrs(chainToMermaidLR(chain, showOnlyActive))
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `ui/components/mermaid/mermaid.templ`, Line: 57, Col: 108}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var2))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var3 string
		templ_7745c5c3_Var3, templ_7745c5c3_Err = templ.JoinStringErrs(chainToMermaidLR(chain, showOnlyActive))
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `ui/components/mermaid/mermaid.templ`, Line: 58, Col: 44}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var3))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "</div></div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

// chainToMermaidLR converts a FunctionChainSummary to a mermaid graph in LR (left-to-right) format
func chainToMermaidLR(chain *models.FunctionChainSummary, showOnlyActive bool) string {
	var out strings.Builder
	out.WriteString("graph LR\n")

	// Add initial node
	out.WriteString("start((Start))\n")

	// Track nodes we've seen to avoid duplicates
	addedNodes := make(map[string]bool)

	// Add edges from the graph
	for _, edge := range chain.Graph {
		// Skip if we're only showing active functions and the source function is complete
		if showOnlyActive {
			fromFn := getFunctionByName(chain, edge.From)
			if fromFn == nil && edge.From != "" {
				panic("function " + edge.From + " not found in chain")
			}
			if fromFn != nil && fromFn.Status == models.SummarizedStatusComplete {
				continue
			}
		}

		// Handle the empty start node
		if edge.From == "" {
			if !addedNodes[edge.To] {
				nodeId := EscapeMermaidNodeId(edge.To)
				out.WriteString(fmt.Sprintf("%s[\"%s\"]\n", nodeId, edge.To))
				addedNodes[edge.To] = true
			}
			out.WriteString(fmt.Sprintf("start --> %s\n", EscapeMermaidNodeId(edge.To)))
			continue
		}

		// Handle the empty end node
		if edge.To == "" {
			out.WriteString(fmt.Sprintf("%s --> done\n", EscapeMermaidNodeId(edge.From)))
			continue
		}

		// Add nodes if we haven't seen them yet
		if !addedNodes[edge.From] {
			nodeId := EscapeMermaidNodeId(edge.From)
			out.WriteString(fmt.Sprintf("%s[\"%s\"]\n", nodeId, edge.From))
			addedNodes[edge.From] = true
		}

		if !addedNodes[edge.To] {
			nodeId := EscapeMermaidNodeId(edge.To)
			out.WriteString(fmt.Sprintf("%s[\"%s\"]\n", nodeId, edge.To))
			addedNodes[edge.To] = true
		}

		// Prepare from and to nodes
		from := EscapeMermaidNodeId(edge.From)
		to := EscapeMermaidNodeId(edge.To)

		// Add diamond for waits
		if edge.Delay != "" {
			// Create wait diamond node
			waitNodeId := fmt.Sprintf("%s_wait", edge.To)
			out.WriteString(fmt.Sprintf("%s{Wait %s}\n", waitNodeId, edge.Delay))

			// Connect through wait node
			out.WriteString(fmt.Sprintf("%s --> %s\n", from, waitNodeId))
			out.WriteString(fmt.Sprintf("%s --> %s\n", waitNodeId, to))
			continue
		}

		// Add diamond for approvals
		if edge.NeedsApproval {
			// Create approval diamond node
			approvalNodeId := fmt.Sprintf("%s_approval", edge.To)
			out.WriteString(fmt.Sprintf("%s{Approval required}\n", approvalNodeId))

			// Connect through approval node
			out.WriteString(fmt.Sprintf("%s --> %s\n", from, approvalNodeId))
			out.WriteString(fmt.Sprintf("%s --> %s\n", approvalNodeId, to))
			continue
		}

		// Regular edge with optional annotation
		if edge.Annotation != "" {
			// Shorten long annotations
			annotation := edge.Annotation
			if len(annotation) > 10 {
				annotation = annotation[:8] + "..."
			}
			out.WriteString(fmt.Sprintf("%s -- %s --> %s\n", from, annotation, to))
		} else {
			out.WriteString(fmt.Sprintf("%s --> %s\n", from, to))
		}
	}

	// Add done node if we had any nodes
	if len(addedNodes) > 0 {
		out.WriteString("done((Done))\n")
	}

	return out.String()
}

// Helper function to find a function by name in the chain
func getFunctionByName(chain *models.FunctionChainSummary, name string) *models.FunctionSummary {
	for _, fn := range chain.Functions {
		if fn.Fn.Name == sdk.FunctionName(name) {
			return fn
		}
	}
	return nil
}

// HandoffGraph renders a mermaid diagram for a handoff graph
func HandoffGraph(edges []sdk.HandoffEdge) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var4 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var4 == nil {
			templ_7745c5c3_Var4 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, "<style>\n\t\t/* Mermaid diagram container */\n\t\t.mermaid-wrapper {\n\t\t\tpadding: 5px 0;\n\t\t}\n\t\t.mermaid-wrapper svg {\n\t\t\tmax-width: 100%;\n\t\t\theight: auto !important;\n\t\t}\n\t</style><!-- Load and initialize Mermaid --><script src=\"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js\"></script><script>\n\t\tdocument.addEventListener('DOMContentLoaded', async function() {\n\t\t\tmermaid.initialize({ \n\t\t\t\tstartOnLoad: false,\n\t\t\t\ttheme: 'neutral',\n\t\t\t\tflowchart: {\n\t\t\t\t\tuseMaxWidth: true,\n\t\t\t\t\thtmlLabels: true,\n\t\t\t\t\tcurve: 'basis',\n\t\t\t\t\trankSpacing: 15,\n\t\t\t\t\tnodeSpacing: 15\n\t\t\t\t},\n\t\t\t\tsecurityLevel: 'loose'\n\t\t\t});\n\n\t\t\tconst elements = document.querySelectorAll('.mermaid');\n\t\t\tfor (const element of elements) {\n\t\t\t\ttry {\n\t\t\t\t\tconst source = element.getAttribute('data-source');\n\t\t\t\t\tawait mermaid.parse(source);\n\t\t\t\t\tawait mermaid.init(undefined, element);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Mermaid rendering error:', error);\n\t\t\t\t\tconsole.error('Failed diagram source:', element.getAttribute('data-source'));\n\t\t\t\t\telement.className = 'mermaid-error';\n\t\t\t\t\telement.innerHTML = `<pre style=\"color: red; white-space: pre-wrap;\">Error rendering diagram:\n${error.message}</pre>`;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t</script><div class=\"mermaid-wrapper overflow-x-auto overflow-y-hidden w-full\"><div class=\"mermaid w-full\" style=\"max-width: 100%;\" data-source=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var5 string
		templ_7745c5c3_Var5, templ_7745c5c3_Err = templ.JoinStringErrs(handoffToMermaidLR(edges))
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `ui/components/mermaid/mermaid.templ`, Line: 222, Col: 94}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var5))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 5, "\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var6 string
		templ_7745c5c3_Var6, templ_7745c5c3_Err = templ.JoinStringErrs(handoffToMermaidLR(edges))
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `ui/components/mermaid/mermaid.templ`, Line: 223, Col: 30}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var6))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 6, "</div></div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

// handoffToMermaidLR converts a slice of HandoffEdge to a mermaid graph in LR (left-to-right) format
func handoffToMermaidLR(edges []sdk.HandoffEdge) string {
	var out strings.Builder
	out.WriteString("graph LR\n")

	// Add start and end nodes
	out.WriteString("start((Start))\n")
	out.WriteString("done((Done))\n")

	// Track nodes we've seen to avoid duplicates
	addedNodes := make(map[string]bool)

	// Add edges from the graph
	for _, edge := range edges {
		// Handle empty start node
		if edge.From == "" {
			if !addedNodes[edge.To] {
				nodeId := EscapeMermaidNodeId(edge.To)
				out.WriteString(fmt.Sprintf("%s[\"%s\"]\n", nodeId, edge.To))
				addedNodes[edge.To] = true
			}
			out.WriteString(fmt.Sprintf("start --> %s\n", EscapeMermaidNodeId(edge.To)))
			continue
		}

		// Handle empty end node
		if edge.To == "" {
			if !addedNodes[edge.From] {
				nodeId := EscapeMermaidNodeId(edge.From)
				out.WriteString(fmt.Sprintf("%s[\"%s\"]\n", nodeId, edge.From))
				addedNodes[edge.From] = true
			}
			out.WriteString(fmt.Sprintf("%s --> done\n", EscapeMermaidNodeId(edge.From)))
			continue
		}

		// Add nodes if we haven't seen them yet
		if !addedNodes[edge.From] {
			nodeId := EscapeMermaidNodeId(edge.From)
			out.WriteString(fmt.Sprintf("%s[\"%s\"]\n", nodeId, edge.From))
			addedNodes[edge.From] = true
		}
		if !addedNodes[edge.To] {
			nodeId := EscapeMermaidNodeId(edge.To)
			out.WriteString(fmt.Sprintf("%s[\"%s\"]\n", nodeId, edge.To))
			addedNodes[edge.To] = true
		}

		// Prepare from and to nodes
		from := EscapeMermaidNodeId(edge.From)
		to := EscapeMermaidNodeId(edge.To)

		// Add diamond for waits
		if edge.Delay != "" {
			// Create wait diamond node with rhombus shape
			waitNodeId := fmt.Sprintf("%s_wait", to)
			out.WriteString(fmt.Sprintf("%s>Wait %s]\n", waitNodeId, edge.Delay))

			// Connect through wait node
			out.WriteString(fmt.Sprintf("%s --> %s\n", from, waitNodeId))
			out.WriteString(fmt.Sprintf("%s --> %s\n", waitNodeId, to))
			continue
		}

		// Add diamond for approvals
		if edge.NeedsApproval {
			// Create approval diamond node with rhombus shape
			approvalNodeId := fmt.Sprintf("%s_approval", to)
			out.WriteString(fmt.Sprintf("%s>Approval required]\n", approvalNodeId))

			// Connect through approval node
			out.WriteString(fmt.Sprintf("%s --> %s\n", from, approvalNodeId))
			out.WriteString(fmt.Sprintf("%s --> %s\n", approvalNodeId, to))
			continue
		}

		// Regular edge with optional annotation
		if edge.Annotation != "" {
			// Shorten long annotations
			annotation := edge.Annotation
			if len(annotation) > 10 {
				annotation = annotation[:8] + "..."
			}
			out.WriteString(fmt.Sprintf("%s -- %s --> %s\n", from, annotation, to))
		} else {
			out.WriteString(fmt.Sprintf("%s --> %s\n", from, to))
		}
	}

	return out.String()
}

var _ = templruntime.GeneratedTemplate
